<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unravel</title>
  </head>
  <body>
    <canvas id="myCanvas" width="4000" height="4000"></canvas>
    <button id="unfold">Unfold</button>
    <style type="text/css">
    body{
      background: #eceaea;
    }
    canvas{
      background: white;
      margin: 30px;
    }

    #unfold{
      position: fixed;
      top: 30px;
      left: 30px;
    }
    </style>
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
        <script type="text/javascript" src="./js/async.min.js"></script>
        <script type="text/javascript" src="./js/jquery.easing.1.3.js"></script>
        <script>
            var canvas = document.getElementById("myCanvas"); //reference canvas
            var canvasContext = canvas.getContext("2d"); //set context

            init();

            function init(){
              var urlToJson = "./data/Achillesstraße.json"

              var pathToData = "./data/";
              // var filesToLoad = ['Achillesstraße.json', 'Columbiadamm.json', 'FrankfurterAllee.json', 'französischeStraße.json', 'Bäckerstraße.json', 'Wartburgstraße.json', 'Hohenstaufenstraße.json', 'Adlergestell.json'];
              var filesToLoad = ['Columbiadamm.json'];
              workFiles(pathToData, filesToLoad);
            }

            function workFiles(pathToData, filesToLoad){
              console.log('');
              console.log('---------------------------');
              console.log('# Start loading files');
              async.map(filesToLoad, function(fileName, callback){
                var urlToJson = pathToData + fileName;
                console.log('Loading '+ urlToJson);
                $.getJSON( urlToJson, function(streetJson) {
                  console.log('Successfully loaded ' + urlToJson);
                  console.log(streetJson);
                  var street = getVectorLine(streetJson);
                  callback(null, street);
                });
              },function(err, streets){
                console.log('# All files loaded');
                console.log('---------------------------');
                console.log('streets', streets);

                // var counter = 0;
                // setInterval(function(){
                //   var value = (-Math.cos(counter/20))/2+0.5;
                //   counter++;
                //   //console.log(value);
                //   test(streets[0], value);
                // },100)

                // var widthCounter = 0;
                // var gap = 0;
                // for (var i = 0; i < streets.length; i++) {
                //   var street = streets[i]
                //   var width = test(street, 1, widthCounter);
                //   widthCounter += width;
                //   widthCounter += gap;
                // };

                var counter = 0;
                setInterval(function(){
                  var value = (-Math.cos(counter/20))/2+0.5;
                  counter++;
                  
                  var widthCounter = 300;
                  var gap = 0;
                  clearCanvas();
                  for (var i = 0; i < streets.length; i++) {
                    var street = streets[i]
                    var width = test(street, value, widthCounter);
                    widthCounter += width;
                    widthCounter += gap;
                  };
                },100)

                // $('#unfold').click(function(){
                //   animateStreet(streets[0]);
                // });
              });
            }

            function test(street, progress, offset){
              //progress is from 
              var progressInverse = 1 - progress; //from 0 to 1;
              var unfold = 1 + progress * 3;
              var scale = 100;

              var unfoldedStreet = getUnfoldedStreet(street, unfold, progressInverse, progressInverse);
              var unfoldedStreetCoordinates = getCoordinatesFromVectors(unfoldedStreet.vectors, unfoldedStreet.origin);
              var lastCoordinate = unfoldedStreetCoordinates[ unfoldedStreetCoordinates.length - 1 ];
              var objectBearing = getBearing( street.origin, lastCoordinate );
              unfoldedStreet.objectBearing = objectBearing;
              unfoldedStreet.objectDistance
              var rotate = -getAngleDifference(unfoldedStreet.objectBearing, 90);
              //var rotate = 90;
              console.log(unfoldedStreet.objectBearing, rotate);
              var width = drawVectors(unfoldedStreet.vectors, {x:offset, y:800}, scale, rotate * progress);
              return width;
            }


            // function animateStreet(street){
            //     var duration = 2000;
            //     var startOfUnfold = 0.55;

            //     var easing = {
            //       restitchTest: 1,
            //       unfoldTest: 1
            //     }

            //     $(easing).animate({restitchTest: 0}, {
            //         duration: duration,
            //         easing: "easeInOutQuart", 
            //         queue: false,
            //         step: function() { 
            //           clearCanvas();
            //           console.log('restitchTest', easing.restitchTest)
            //           drawVectors(getUnfoldedStreet(street, easing.unfoldTest, easing.restitchTest), {x:600, y:800}, 150);
            //         }
            //     });

            //     window.setTimeout(function(){
            //       $(easing).animate({unfoldTest: 3}, {
            //           duration: 2000,
            //           queue: false,
            //           easing: "easeInOutQuad", 
            //           step: function() { 
            //             clearCanvas();
            //             drawVectors(getUnfoldedStreet(street, easing.unfoldTest, easing.restitchTest), {x:600, y:800}, 150);
            //           }
            //       });
            //     }, 2000);
            // }

            function getUnfoldedStreet(street, unfold, closeGaps, straightenPathConnections){
              //closeGaps: Number between 0 (no gap) and 1 (original gap), larger numbers will result in larger gaps
              //unfold: Number between 1 (original) and inifinity (use values from 1 to around 5)
              //straightenPathConnections: Number between 0 (straight from last vector to now) and 1 (original angle)

              var previousVectorType;
              var newVectors = JSON.parse(JSON.stringify(street.vectors));

              for (var i = 0; i < newVectors.length; i++) {
                var vector = newVectors[i];
                if (vector.type == "translation") {
                  vector.deltaBearing = vector.deltaBearing*closeGaps;
                  vector.distance = vector.distance * closeGaps;
                };
                if (i!=0) { //for all except the first one
                  vector.deltaBearing = vector.deltaBearing / unfold;
                  if (previousVectorType == "translation") {
                    vector.deltaBearing = vector.deltaBearing * straightenPathConnections;
                  };
                };

                //last vector
                if (i == newVectors.length - 1) {

                };
                previousVectorType = vector.type;
              };


              var newStreet = {
                origin: JSON.parse(JSON.stringify(street.origin)),
                tags: JSON.parse(JSON.stringify(street.tags)),
                vectors: newVectors
              }
              
              return newStreet;
            }

            function getCoordinatesFromVectors(vectors, origin){
              var coordinates = [];
              var bearingCounter = 0;

              coordinates.push(origin);
              var cursor = JSON.parse(JSON.stringify(origin));
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;
                cursor = getDestination(cursor, vector.distance, bearingCounter);

                coordinates.push(cursor);
              };

              return coordinates;
            }

            function drawVectors(vectors, origin, scale, rotation){
              var bearingCounter = rotation;
              var currentX = origin.x;
              var currentY = origin.y;
              var previousX = currentX;
              var previousY = currentY;

              var kmInPixel = scale; //= 1km
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;

                var pixelDistance = vector.distance * kmInPixel;
                //not correct because geo, but ok for our scale, use turf.destination() instead
                var dx = Math.sin(toRadians(bearingCounter)) * pixelDistance;
                var dy = Math.cos(toRadians(bearingCounter)) * pixelDistance;

                currentX += dx;
                currentY -= dy;

                if (vector.type == "street") {
                  canvasContext.strokeStyle = '#00B7BF';
                }else if(vector.type == "translation") {
                  canvasContext.strokeStyle = 'rgba(0,0,0,0.06)';
                  //canvasContext.strokeStyle = 'rgba(0,0,0,0)';
                }

                canvasContext.beginPath(); 
                canvasContext.moveTo(previousX, previousY);
                canvasContext.lineTo(currentX, currentY);
                canvasContext.stroke();
                canvasContext.closePath();

                previousX = currentX;
                previousY = currentY;
              };
              return currentX - origin.x;
            }

            function getVectorLine(street){
              var components = street.components;
              var previousNode;
              var previousBearing;

              var output = {};
                  output.tags = street.tags;
                  output.vectors = [];

              for (var c = 0; c < components.length; c++) {
                var component = components[c];
                var paths = component;

                for (var p = 0; p < paths.length; p++) {
                  var path = paths[p];

                  for (var n = 0; n < path.length; n++) {
                    var node = path[n];

                    //If first node of everything, then set origin and don't create vector (since a vector needs two nodes)
                    if (c==0 && p==0 && n==0) {
                      //Set Origin
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      output.origin = currentNodeLocation;
                    }else{
                      //Add Vector (gaps are also vectors)
                      var type;
                      var deltaBearing;
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      var previousNodeLocation = getCoordinateFromNode(previousNode, street.nodes);

                      var bearing = getBearing( previousNodeLocation, currentNodeLocation ); //in deg
                      var distance = getDistance( previousNodeLocation, currentNodeLocation ); //in km

                      //If it is the first vector, use the globale bearing, since it compares to the y-axis
                      if (c==0 && p==0 && n==1) { //if second node (first vector) of everything
                        deltaBearing = bearing;
                      }else{
                        deltaBearing = getAngleDifference( bearing, previousBearing );
                      }

                      //If first node of path (n==0), then the vector ending here is translation
                      if (n==0) { type = "translation";
                      }else{      type = "street";    }

                      //If last node of everything, then add destination and bearing of the object
                      if (p == paths.length -1 && n == path.length - 1 && c == components.length - 1) { 
                        console.log('last bit');
                        output.destination = currentNodeLocation;
                        output.objectBearing = getBearing( output.origin, output.destination );
                      };

                      //Prepare to output
                      var vector = {
                        deltaBearing: deltaBearing,
                        distance: distance,
                        type: type
                      }
                      output.vectors.push(vector);

                      //Update previous bearing (used to calculate the bearing difference)
                      previousBearing = bearing;
                    }

                    //Update previous node (used to calculate the vectors)
                    previousNode = node;
                  };
                };
              };
              return output;
            }







            //--------------------------
            //         Helpers
            //--------------------------

            function getAngleDifference(angle1, angle2){
              var d = angle1 - angle2
               while (d < -180) {
                  d += 360;
                };
                while (d > 180) {
                  d -= 360;
                };
              return d;
            }

            function getBearing(from, to){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.point([to.lon, to.lat]);
              return turf.bearing(fromPoint, toPoint);
            }

            function getDistance(from, to){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.point([to.lon, to.lat]);
              return turf.distance(fromPoint, toPoint);
            }

            function getDestination(from, distance, bearing){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.destination(fromPoint, distance, bearing);
              return {lon: toPoint.geometry.coordinates[0], lat: toPoint.geometry.coordinates[1]}
            }

            function toRadians(degrees) {
              return degrees * Math.PI / 180;
            };

            function getCoordinateFromNode(node, nodes){
              return nodes[node];
            }

            function clearCanvas(){
              canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            }

        </script>
  </body>
</html>