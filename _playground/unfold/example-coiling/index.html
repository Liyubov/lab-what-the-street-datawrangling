<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Coiling Example</title>
    <style>
        body{
            font-family: 'Helvetica Neue', sans-serif;
        }

        h1{
            padding-top: 15px;
        }

        h2{
            font-weight: normal;
            padding-bottom: 15px;
        }

        h1, h2{
            font-size: 18px;
            width: 800px;
            margin: auto;
        }

        svg{
            margin: auto;
            display: block;
        }

        #svg{
            text-align: center;            
            color: #ababab;
        }

        #bottom{
            position: fixed;
            bottom: 30px;
            left: 130px;
            text-align: right;
            font-size: 1.5rem;
        }

        #bottom:hover{
            cursor: pointer;
        }
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="../js/unfold.js"></script>
    <script type="text/javascript" src="../js/coil.js"></script>
    <script type="text/javascript">
        $( document ).ready(function() {
            $('#bottom').on('click', function(){
                $('html, body').animate({
                    scrollTop: $("#conclusion").offset().top
                }, 30000);
            })
            processFile("../data/161202_Berlin_fromMongodb.json");
        });

        function processFile(url){
            $.getJSON( url, function(streets) {

                var widthCounter = 0;
                var gapBetweeStreets = 2; //in m
                meterPerPixel = 1;

                var pixelStreets = [];

                for (var i = 0; i < streets.length; i++) {
                //for (var i = 0; i < 20; i++) {
                //for (var i = 0; i < 1200; i++) {
                    var street = streets[i];
                    var vectorStreet = unfold.getStreetWithVectors( street );

                    var unfoldedStreet = getUnfoldedStreetSimple(vectorStreet, 1, 2);
                    unfold.calculateAndSetObjectBearing(unfoldedStreet);
                    var delta = getAngleDifference(90, unfoldedStreet.objectBearing);
                    unfold.rotateVectorStreet(unfoldedStreet, delta);
                    var newUnfoldedStreet = unfold.subdivideVectorStreet(unfoldedStreet, 1);
                    var pixelStreet = getStreetInPixels(newUnfoldedStreet, meterPerPixel);
                    pixelStreets.push(pixelStreet);
                };

                coil.setProperties(600, 5, [100, 300]);
                var svgCode = coil.getSvgCode(pixelStreets, unfold.getDistanceInPixels(gapBetweeStreets, meterPerPixel));
                $('#svg').html(svgCode);
            });
        }

        function getStreetInPixels(vectorStreet, meterPerPixel){
            var output = JSON.parse( JSON.stringify(vectorStreet) );
                delete output.vectors;
                delete output.origin;
                delete output.destination;

            var cursor = {
                x: 0,
                y: 0
            };
            var previousCursor;
            var vectors = vectorStreet.vectors;
            var bearingCounter = 0;

            var coordinates = [];

            for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;

                var distanceInMeter = vector.distance * 1000;
                var distanceInPixel = unfold.getDistanceInPixels(distanceInMeter, meterPerPixel);
                var dx = Math.sin(toRadians(bearingCounter)) * distanceInPixel;
                var dy = Math.cos(toRadians(bearingCounter)) * distanceInPixel;                

                cursor.x += dx;
                cursor.y -= dy;

                // if (vector.type == "translation") {
                // }else{
                // }
                coordinates.push({x: cursor.x, y: cursor.y})
            };
            output.coordinates = coordinates;
            return output;
        }

        // Returns coordinates of unfolded street
        //
        //   progress: How far animation has 
        //      From:  0 (start - no change)
        //      To:    1 (end - fully unfolded and rotated that start- and endpoint are on the same y)
        //
        //   unfoldAmplitude: How far 
        //     From:   0 (no unravel)
        //     To:     Infinity (values until 30 work nicely)
        function getUnfoldedStreetSimple(vectorStreet, progress, unfoldAmplitude){
            var unfoldFactor = 1 + progress * unfoldAmplitude;
            var output = unfold.getUnfoldedVectorStreet(vectorStreet, unfoldFactor, progress, progress);
            return output;
        }

        function getMeterPerPixel(lat, zoomLevel){
            return (40075016.686 * Math.abs(Math.cos(toRadians(lat))) / Math.pow(2, zoomLevel + 8));
        }

        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function getAngleDifference(angle1, angle2){
            var d = angle1 - angle2
             while (d < -180) {
                d += 360;
              };
              while (d > 180) {
                d -= 360;
              };
            return d;
          }
    </script>
  </head>
  <body>
    <h1>Coiling Example</h1>
    <h2>How Coiling Streets Could Work</h2> 
    <div id="svg">Calculating ... </br>(this will take a while)</div>
    <div id="conclusion"></div>
    <div id="bottom">â†“</div>
  </body>
 </html>