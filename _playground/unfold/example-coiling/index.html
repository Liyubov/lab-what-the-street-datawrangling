<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Coiling Example</title>
    <style>
        body{
            font-family: 'Helvetica Neue', sans-serif;
        }

        h1{
            padding-top: 15px;
        }

        h2{
            font-weight: normal;
            padding-bottom: 15px;
        }

        h1, h2{
            font-size: 18px;
            width: 800px;
            margin: auto;
        }

        svg{
            margin: auto;
            display: block;
        }

        #svg{
            position: absolute;
            text-align: center;            
            color: #ababab;
        }

        #bottom{
            position: fixed;
            bottom: 30px;
            left: 130px;
            text-align: right;
            font-size: 1.5rem;
        }

        #canvas{
            /*background: rgba(0,0,0,0.1);*/
            position: absolute;
            top: 0;
            left: 0;
        }

        #bottom:hover{
            cursor: pointer;
        }

        #map { position:fixed; top:0; bottom:0; width: vw; height: vh;}
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
    <script type="text/javascript" src="../js/unfold.js"></script>
    <script type="text/javascript" src="../js/coil.js"></script>
    <script type="text/javascript">
        var canvas;
        var context;

        $.easing.easeOutBounce = function (x, t, b, c, d) {
            if ((t/=d) < (1/2.75)) {
                return c*(7.5625*t*t) + b;
            } else if (t < (2/2.75)) {
                return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
            } else if (t < (2.5/2.75)) {
                return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
            } else {
                return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
            }
        };

        $( document ).ready(function() {
            canvas = document.getElementById("canvas");
            canvas.width = $(window).width();
            canvas.height = 3000;
            context = canvas.getContext("2d");

            $('#bottom').on('click', function(){
                $('html, body').animate({
                    scrollTop: $("#conclusion").offset().top
                }, 30000);
            })
            processFile("../data/161213_berlin_streets.json");
        });

        function processFile(url){
            $.getJSON( url, function(streets) {

                var widthCounter = 0;
                var gapBetweeStreets = 0.005; //in km

                var widthInMeter = 729;
                var widthInPixels = 592;
                meterPerPixel = widthInMeter/widthInPixels;

                var coiledStreets = [];
                var vectorStreets = [];

                var positionOnCoilCounter = 0;
                //for (var i = 0; i < streets.length; i++) {
                for (var i = 0; i < 30; i++) {
                    coil.setProperties(widthInMeter, 5)
                    var street = streets[i];
                    var vectorStreet = unfold.getStreetWithVectors( street );
                    var vectorStreetDivided = unfold.subdivideVectorStreet(vectorStreet, 1);
                
                    var coiledStreet = coil.getCoiledStreet(vectorStreetDivided, positionOnCoilCounter);
                    positionOnCoilCounter += (coiledStreet.coilEnd - coiledStreet.coilStart)
                    positionOnCoilCounter += gapBetweeStreets;
                    
                    coiledStreets.push( coiledStreet );
                    console.log(i, coiledStreet.tags.name, coiledStreet)
                    vectorStreets.push( vectorStreetDivided );
                };

                var svgCode = generateSVG(coiledStreets, meterPerPixel)

                $('#svg').html(svgCode);
                $('path#Adersleber_Weg').css('stroke', '#000');
                $('path#Adersleber_Weg').click(function(){
                    $(this).hide();
                    console.log('clicked');
                    console.log(coiledStreets[27]);
                    animate(vectorStreets[27], coiledStreets[27], meterPerPixel);
                })
            });
        }

        function animate(vectorStreet, coiledStreet, meterPerPixel){
            var timingFactor = Math.max(coiledStreet.length * 150, 1000);

            testDraw(vectorStreet, coiledStreet, 0, 0, meterPerPixel);

            $({progressUnfold: 0}).delay(200).animate(
                {progressUnfold: 1}, 
                {duration: timingFactor*2, 
                 easing: "easeOutBounce",
                 progress: function(animation, progress) {
                    clearCanvas();
                    testDraw(vectorStreet, coiledStreet, this.progressUnfold, 0, meterPerPixel);
                 },
                 complete: function (argument) {
                     $({progressStitch: 0}).delay(300).animate(
                        {progressStitch: 1}, 
                        {duration: timingFactor*1.2, 
                         easing: "easeInOutBack",
                         progress: function(animation, progress) {
                            clearCanvas();
                            testDraw(vectorStreet, coiledStreet, 1, this.progressStitch, meterPerPixel);
                         },
                         complete: function(){
                            $({progressUnfold: 1, progressStitch: 1}).delay(800).animate(
                                {progressUnfold: 0, progressStitch: 0}, 
                                {duration: timingFactor*2, 
                                 easing: "easeInOutCubic",
                                 progress: function(animation, progress) {
                                    clearCanvas();
                                    testDraw(vectorStreet, coiledStreet, this.progressUnfold, this.progressStitch, meterPerPixel);}
                                    , complete: function(){
                                        //animate(vectorStreet, coiledStreet)
                                    }
                                })
                         }
                        }
                    );
                 }
                }
            );
        }

        function generateSVG(coiledStreets, meterPerPixel){
            var svgPieces = [];
            for (var i = 0; i < coiledStreets.length; i++) {
                var coiledStreet = coiledStreets[i];
                var path = generatePath(coiledStreet, meterPerPixel);
                svgPieces.push(path);
            };

            svgPieces.push('</svg>');
            svgPieces.unshift('<svg width="800px" height="3000px"  viewBox="0 0 800 3000">');
            var svgCode = svgPieces.join('');
            return svgCode;
        }

        function generatePath(coiledStreet, meterPerPixel){
            var scale = meterPerPixel / 1000;
            var cursor = {
                x:100 + coiledStreet.coilOrigin.x / scale, 
                y:100 + coiledStreet.coilOrigin.y / scale
            };

            var coiledGeometry = coiledStreet.vectors;

            var angleCounter = 0;
            var pathPieces = [];
            var name = coiledStreet.tags.name.name || coiledStreet.tags.name || "unnamed";
            name = name.replace(" ", "_");
            pathPieces.push('<path id="' + name + '" stroke="#50E3C2" stroke-width="5" fill="none" d="');
            for (var j = 0; j < coiledGeometry.length; j++) {
                var vector = coiledGeometry[j];
                angleCounter += vector.deltaAngle;
                var distance = vector.distance / scale;
                var dx = Math.sin( toRadians(angleCounter) ) * distance;
                var dy = Math.cos( toRadians(angleCounter) ) * distance;

                cursor.x += dx;
                cursor.y -= dy;

                if (j==0) {
                    pathPieces.push('M' + cursor.x + ',' + cursor.y + ' ');
                }else{
                    pathPieces.push('L' + cursor.x + ',' + cursor.y + ' ');  
                }
            }

            pathPieces.push('" />');

            var svgCode = pathPieces.join('');
            return svgCode;
        }

        function testDraw(originalStreet, coiledStreet, progressUnfold, progressRestitch, meterPerPixel){
            var scale = meterPerPixel / 1000;
            var originalGeometry = originalStreet.vectors;
            var coiledGeometry = coiledStreet.vectors;

            var cursor = {
                x:108 + coiledStreet.coilOrigin.x / scale, 
                y:183 + coiledStreet.coilOrigin.y / scale
            };

            var angleCounter = 0;

            for (var j = 0; j < coiledGeometry.length; j++) {
                var angleDiff = getAngleDifference(originalGeometry[j].deltaBearing, coiledGeometry[j].deltaAngle);
                var distanceDiff = originalGeometry[j].distance - coiledGeometry[j].distance;

                var vector = coiledGeometry[j];

                var distance = (vector.distance + distanceDiff * progressUnfold) / scale;
                if (originalGeometry[j].type == "translation") {
                    distance = distance * progressRestitch;
                }
                
                angleCounter += vector.deltaAngle + angleDiff * progressUnfold;

                var dx = Math.sin( toRadians(angleCounter) ) * distance;
                var dy = Math.cos( toRadians(angleCounter) ) * distance;

                if (originalGeometry[j].type == "translation") {
                    context.lineWidth = "1";
                    context.strokeStyle = "rgba(0,0,0, 0)";
                }else{
                    context.lineWidth = "5";
                    context.strokeStyle = "#000";
                }

                context.beginPath();
                context.moveTo(cursor.x, cursor.y);

                cursor.x += dx;
                cursor.y -= dy;

                context.lineTo(cursor.x, cursor.y);
                context.stroke();
                context.closePath();
            };
        }

        // Returns coordinates of unfolded street
        //
        //   progress: How far animation has 
        //      From:  0 (start - no change)
        //      To:    1 (end - fully unfolded and rotated that start- and endpoint are on the same y)
        //
        //   unfoldAmplitude: How far 
        //     From:   0 (no unravel)
        //     To:     Infinity (values until 30 work nicely)
        function getUnfoldedStreetSimple(vectorStreet, progress, unfoldAmplitude){
            var unfoldFactor = 1 + progress * unfoldAmplitude;
            var output = unfold.getUnfoldedVectorStreet(vectorStreet, unfoldFactor, progress, progress);
            return output;
        }

        function clearCanvas(){
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

        function getMeterPerPixel(lat, zoomLevel){
            return (40075016.686 * Math.abs(Math.cos(toRadians(lat))) / Math.pow(2, zoomLevel + 9));
        }

        function getZoomLevel(lat, pixelPerMeter){
            return Math.log2(40075016.686 * ( Math.cos(toRadians(lat))/pixelPerMeter )) - 9;
        }

        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function getAngleDifference(angle1, angle2){
            var d = angle1 - angle2
             while (d < -180) {
                d += 360;
              };
              while (d > 180) {
                d -= 360;
              };
            return d;
          }
    </script>
  </head>
  <body>
    <h1>Coiling Example</h1>
    <h2>How Coiling Streets Could Work</h2> 
    <canvas id='canvas'></canvas> 
    <div id="svg">Calculating ... </br>(this will take a while)</div>
    <div id="conclusion"></div>
    <!-- <div id="bottom">↓</div> -->
  </body>
 </html>