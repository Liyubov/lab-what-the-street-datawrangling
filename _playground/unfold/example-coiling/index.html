<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Coiling Example</title>
    <style>
        body{
            margin: 0;
            padding: 0;
            font-family: 'Helvetica Neue', sans-serif;
        }

        h1{
            padding-top: 15px;
        }

        h2{
            font-weight: normal;
            padding-bottom: 15px;
        }

        h1, h2{
            font-size: 18px;
            width: 800px;
            margin: auto;
        }

        svg{
            margin: auto;
            display: block;
        }

        #svg{
            position: absolute;
            text-align: center;            
            color: #ababab;
            transition: 0.3s;
        }

        #bottom{
            position: fixed;
            bottom: 30px;
            left: 130px;
            text-align: right;
            font-size: 1.5rem;
        }

        #canvas{
            /*background: rgba(0,0,0,0.1);*/
            position: absolute;
            top: 0;
            left: 0;
        }

        #bottom:hover{
            cursor: pointer;
        }

        #map { 
            position:fixed; 
            top:0; 
            bottom:0; 
            width: 100vw;
            height: 100vh;
            transition: 0.3s;
        }

        .invisible{
            opacity: 0.001;
        }
    </style>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.28.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.28.0/mapbox-gl.css' rel='stylesheet' />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
    <script type="text/javascript" src="../js/unfold.js"></script>
    <script type="text/javascript" src="../js/coil.js"></script>
    <script type="text/javascript">
        // var canvas;
        // var context;
        var map;

        $.easing.easeOutBounce = function (x, t, b, c, d) {
            if ((t/=d) < (1/2.75)) {
                return c*(7.5625*t*t) + b;
            } else if (t < (2/2.75)) {
                return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
            } else if (t < (2.5/2.75)) {
                return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
            } else {
                return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
            }
        };

        $( document ).ready(function() {
            mapboxgl.accessToken = 'pk.eyJ1IjoiYm9nbmVyc3RlcGhhbiIsImEiOiJBMnlqbnZrIn0.YwiGRgpheNMPujZn-JBh6Q';
            map = new mapboxgl.Map({
                container: 'map', // container id
                style: 'mapbox://styles/mapbox/streets-v9', //stylesheet location
                center: [-74.50, 40], // starting position
                zoom: 9 // starting zoom
            });

            map.on('load', function () {
                addSource('street');
            });

            // canvas = document.getElementById("canvas");
            // canvas.width = $(window).width();
            // canvas.height = 3000;
            //context = canvas.getContext("2d");

            $('#bottom').on('click', function(){
                $('html, body').animate({
                    scrollTop: $("#conclusion").offset().top
                }, 30000);
            })
            processFile("../data/161213_berlin_streets.json");
        });

        function processFile(url){
            $.getJSON( url, function(streets) {

                var widthCounter = 0;
                var gapBetweeStreets = 0.005; //in km

                var widthInMeter = 729;
                var widthInPixels = 592;
                meterPerPixel = widthInMeter/widthInPixels;

                var coiledStreets = [];
                var vectorStreets = [];

                var positionOnCoilCounter = 0;
                //for (var i = 0; i < streets.length; i++) {
                for (var i = 0; i < 30; i++) {
                    coil.setProperties(widthInMeter, 5)
                    var street = streets[i];
                    var vectorStreet = unfold.getStreetWithVectors( street );
                    var vectorStreetDivided = unfold.subdivideVectorStreet(vectorStreet, 1);
                
                    var coiledStreet = coil.getCoiledStreet(vectorStreetDivided, positionOnCoilCounter);
                    positionOnCoilCounter += (coiledStreet.coilEnd - coiledStreet.coilStart)
                    positionOnCoilCounter += gapBetweeStreets;
                    
                    coiledStreets.push( coiledStreet );
                    console.log(i, coiledStreet.tags.name, coiledStreet)
                    vectorStreets.push( vectorStreetDivided );
                };

                var svgCode = generateSVG(coiledStreets, meterPerPixel)

                $('#svg').html(svgCode);
                $('path#Aalemannufer').css('stroke', '#000');
                $('path#Aalemannufer').click(function(){
                    var coiledStreetToUncoil = coiledStreets[1];
                    var vectorStreetToUncoil = vectorStreets[1];

                    $(this).hide();
                    $('#svg').addClass('invisible');
                    $('#map').removeClass('invisible');
                    console.log('clicked');
                    console.log(coiledStreetToUncoil);

                    var zoomLevel = getZoomLevel(coiledStreetToUncoil.origin.lat, meterPerPixel)
                    map.setZoom(zoomLevel);

                    var x = 100 + coiledStreetToUncoil.coilOrigin.x / (meterPerPixel/1000);
                    var y = 175 + coiledStreetToUncoil.coilOrigin.y / (meterPerPixel/1000);

                    var percentagePixelHor = (x / $(window).width());
                    var percentagePixelVer = (y / $(window).height());
                    var newCenter = [coiledStreetToUncoil.origin.lon, coiledStreetToUncoil.origin.lat];

                    newCenterAt(map, newCenter, percentagePixelHor, percentagePixelVer);
                    var bounds = [coiledStreetToUncoil.bounds.ne, coiledStreetToUncoil.bounds.sw];

                    plotStreetOnMap(vectorStreetToUncoil, coiledStreetToUncoil, 0, 0);

                    window.setTimeout(function(){
                        window.setTimeout(function(){
                            map.fitBounds(bounds, {maxZoom: zoomLevel, padding: 30, speed: 0.3});
                        },500);

                        
                        map.on('moveend', function() {
                            animate(vectorStreetToUncoil, coiledStreetToUncoil);
                        })
                    },700);
                })
            });
        }

        function newCenterAt(map, center, fromLeft, fromTop){
            map.setCenter(center);
            var bounds = map.getBounds();
            var dLat = bounds._ne.lat - bounds._sw.lat;
            var dLon = bounds._ne.lng - bounds._sw.lng;

            var offsetLat = - 0.5 + fromTop;
            var offsetLon = - 0.5 + fromLeft;

            var center = map.getCenter();

            var newLat = center.lat + offsetLat * dLat;
            var newLon = center.lng - offsetLon * dLon;
            map.setCenter([newLon, newLat]);
        }

        function animate(vectorStreet, coiledStreet){
            var timingFactor = Math.max(coiledStreet.length * 150, 1000);

            plotStreetOnMap(vectorStreet, coiledStreet, 0, 0);

            $({progressUnfold: 0}).delay(200).animate(
                {progressUnfold: 1}, 
                {duration: timingFactor*2, 
                 easing: "easeOutBounce",
                 progress: function(animation, progress) {
                    //clearCanvas();
                    plotStreetOnMap(vectorStreet, coiledStreet, this.progressUnfold, 0);
                 },
                 complete: function (argument) {
                     $({progressStitch: 0}).delay(300).animate(
                        {progressStitch: 1}, 
                        {duration: timingFactor*1.2, 
                         easing: "easeInOutBack",
                         progress: function(animation, progress) {
                            //clearCanvas();
                            plotStreetOnMap(vectorStreet, coiledStreet, 1, this.progressStitch);
                         },
                         complete: function(){
                            // $({progressUnfold: 1, progressStitch: 1}).delay(800).animate(
                            //     {progressUnfold: 0, progressStitch: 0}, 
                            //     {duration: timingFactor*2, 
                            //      easing: "easeInOutCubic",
                            //      progress: function(animation, progress) {
                            //         clearCanvas();
                            //         plotStreetOnMap(vectorStreet, coiledStreet, this.progressUnfold, this.progressStitch);}
                            //         , complete: function(){
                            //             //animate(vectorStreet, coiledStreet)
                            //         }
                            //     })
                         }
                        }
                    );
                 }
                }
            );
        }

        function generateSVG(coiledStreets, meterPerPixel){
            var svgPieces = [];
            for (var i = 0; i < coiledStreets.length; i++) {
                var coiledStreet = coiledStreets[i];
                var path = generatePath(coiledStreet, meterPerPixel);
                svgPieces.push(path);
            };

            svgPieces.push('</svg>');
            svgPieces.unshift('<svg width="800px" height="3000px"  viewBox="0 0 800 3000">');
            var svgCode = svgPieces.join('');
            return svgCode;
        }

        function generatePath(coiledStreet, meterPerPixel){
            var scale = meterPerPixel / 1000;
            var cursor = {
                x:100 + coiledStreet.coilOrigin.x / scale, 
                y:100 + coiledStreet.coilOrigin.y / scale
            };

            var coiledGeometry = coiledStreet.vectors;

            var angleCounter = 0;
            var pathPieces = [];
            var name = coiledStreet.tags.name.name || coiledStreet.tags.name || "unnamed";
            name = name.replace(" ", "_");
            pathPieces.push('<path id="' + name + '" stroke="#50E3C2" stroke-width="5" fill="none" d="');
            for (var j = 0; j < coiledGeometry.length; j++) {
                var vector = coiledGeometry[j];
                angleCounter += vector.deltaAngle;
                var distance = vector.distance / scale;
                var dx = Math.sin( toRadians(angleCounter) ) * distance;
                var dy = Math.cos( toRadians(angleCounter) ) * distance;

                cursor.x += dx;
                cursor.y -= dy;

                if (j==0) {
                    pathPieces.push('M' + cursor.x + ',' + cursor.y + ' ');
                }else{
                    pathPieces.push('L' + cursor.x + ',' + cursor.y + ' ');  
                }
            }

            pathPieces.push('" />');

            var svgCode = pathPieces.join('');
            return svgCode;
        }

        function plotStreetOnMap(originalStreet, coiledStreet, progressUnfold, progressRestitch){
            var origin = {
              "type": "Feature",
              "geometry": {
                "type": "Point",
                "coordinates": [originalStreet.origin.lon, originalStreet.origin.lat]
              }
            };

            var cursor = JSON.parse( JSON.stringify(origin) );
            var coordinates = [];

            var originalGeometry = originalStreet.vectors;
            var coiledGeometry = coiledStreet.vectors;

            var angleCounter = 0;

            var lineStrings = [];
            for (var j = 0; j < coiledGeometry.length; j++) {
                var angleDiff = getAngleDifference(originalGeometry[j].deltaBearing, coiledGeometry[j].deltaAngle);
                var distanceDiff = originalGeometry[j].distance - coiledGeometry[j].distance;

                var vector = coiledGeometry[j];

                var distance = vector.distance + distanceDiff * progressUnfold;
                if (originalGeometry[j].type == "translation") {
                    distance = distance * progressRestitch;
                }

                //1st coordinate
                if (originalGeometry[j].type != "translation") {
                    coordinates.push(cursor.geometry.coordinates);
                }
                
                angleCounter += vector.deltaAngle + angleDiff * progressUnfold;

                cursor = turf.destination(cursor, distance, angleCounter);

                //2st coordinate
                if (originalGeometry[j].type != "translation") {
                    coordinates.push(cursor.geometry.coordinates);
                }

                //if new vector is translation
                if (originalGeometry[j].type == "translation" && coordinates.length > 0) {
                    lineStrings.push( turf.lineString(coordinates) );
                    coordinates = [];
                }
            }

            if (coordinates.length > 0) {
                lineStrings.push( turf.lineString(coordinates) );
                coordinates = [];
            }

            var featureCollection = turf.featureCollection(lineStrings);
            console.log(featureCollection);
            map.getSource('street').setData(featureCollection);
        }


        function addSource(name){
            map.addSource(name, {
                "type": "geojson",
                "data": {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "LineString",
                        "coordinates": [
                            [-122.48369693756104, 37.83381888486939],
                            [-122.48348236083984, 37.83317489144141]
                        ]
                    }
                }
            });
            map.addLayer({
                "id": name,
                "type": "line",
                "source": name,
                "layout": {
                    "line-join": "round",
                    "line-cap": "round"
                },
                "paint": {
                    "line-color": "#000",
                    "line-width": 5
                }
            });
        }


        // Returns coordinates of unfolded street
        //
        //   progress: How far animation has 
        //      From:  0 (start - no change)
        //      To:    1 (end - fully unfolded and rotated that start- and endpoint are on the same y)
        //
        //   unfoldAmplitude: How far 
        //     From:   0 (no unravel)
        //     To:     Infinity (values until 30 work nicely)
        function getUnfoldedStreetSimple(vectorStreet, progress, unfoldAmplitude){
            var unfoldFactor = 1 + progress * unfoldAmplitude;
            var output = unfold.getUnfoldedVectorStreet(vectorStreet, unfoldFactor, progress, progress);
            return output;
        }

        // function clearCanvas(){
        //     context.clearRect(0, 0, canvas.width, canvas.height);
        // }

        function getMeterPerPixel(lat, zoomLevel){
            return (40075016.686 * Math.abs(Math.cos(toRadians(lat))) / Math.pow(2, zoomLevel + 9));
        }

        function getZoomLevel(lat, meterPerPixel){
            return Math.log2(40075016.686 * ( Math.cos(toRadians(lat))/meterPerPixel )) - 9;
        }

        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function getAngleDifference(angle1, angle2){
            var d = angle1 - angle2
             while (d < -180) {
                d += 360;
              };
              while (d > 180) {
                d -= 360;
              };
            return d;
          }
    </script>
  </head>
  <body>
    <h1>Coiling Example</h1>
    <h2>How Coiling Streets Could Work</h2> 
    <div id="map" class="invisible"></div>
    <!-- <canvas id='canvas'></canvas>  -->
    <div id="svg">Calculating ... </br>(this will take a while)</div>
    <div id="conclusion"></div>
    <!-- <div id="bottom">↓</div> -->
  </body>
 </html>