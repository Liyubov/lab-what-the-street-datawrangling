<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Coiling Example</title>
    <style>
        body{
            font-family: 'Helvetica Neue', sans-serif;
        }

        h1{
            padding-top: 15px;
        }

        h2{
            font-weight: normal;
            padding-bottom: 15px;
        }

        h1, h2{
            font-size: 18px;
            width: 800px;
            margin: auto;
        }

        svg{
            margin: auto;
            display: block;
        }

        #svg{
            text-align: center;            
            color: #ababab;
        }

        #bottom{
            position: fixed;
            bottom: 30px;
            left: 130px;
            text-align: right;
            font-size: 1.5rem;
        }

        #bottom:hover{
            cursor: pointer;
        }

        #map { position:fixed; top:0; bottom:0; width: vw; height: vh;}
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
    <script type="text/javascript" src="../js/unfold.js"></script>
    <script type="text/javascript" src="../js/coil.js"></script>
    <script type="text/javascript">
        var canvas;
        var context;

        $.easing.easeOutBounce = function (x, t, b, c, d) {
            if ((t/=d) < (1/2.75)) {
                return c*(7.5625*t*t) + b;
            } else if (t < (2/2.75)) {
                return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
            } else if (t < (2.5/2.75)) {
                return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
            } else {
                return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
            }
        };

        $( document ).ready(function() {
            canvas = document.getElementById("canvas");
            context = canvas.getContext("2d");

            $('#bottom').on('click', function(){
                $('html, body').animate({
                    scrollTop: $("#conclusion").offset().top
                }, 30000);
            })
            processFile("../data/161202_Berlin_fromMongodb.json");
        });

        function processFile(url){
            $.getJSON( url, function(streets) {

                var widthCounter = 0;
                var gapBetweeStreets = 0.005; //in km

                var widthInMeter = 729;
                var widthInPixels = 592;
                meterPerPixel = widthInMeter/widthInPixels;

                var coiledStreets = [];
                var vectorStreets = [];

                var positionOnCoilCounter = 0;
                //for (var i = 0; i < streets.length; i++) {
                for (var i = 0; i < 100; i++) {
                //for (var i = 0; i < 1200; i++) {
                    coil.setProperties(widthInMeter, 5)
                    var street = streets[i];
                    var vectorStreet = unfold.getStreetWithVectors( street );
                    var vectorStreetDivided = unfold.subdivideVectorStreet(vectorStreet, 1);
                
                    var coiledStreet = coil.getCoiledStreet(vectorStreetDivided, positionOnCoilCounter);
                    positionOnCoilCounter += (coiledStreet.coilEnd - coiledStreet.coilStart)
                    positionOnCoilCounter += gapBetweeStreets;
                    
                    coiledStreets.push( coiledStreet );
                    vectorStreets.push( vectorStreetDivided );
                };

                for (var i = 0; i < coiledStreets.length; i++) {
                    testDraw(vectorStreets[i], coiledStreets[i], 0, 0, meterPerPixel);
                    //if (i == 9) {
                     //   animate(vectorStreets[i], coiledStreets[i]);
                    //};
                };
        });
    }

        function animate(vectorStreet, coiledStreet){
            var scale = 800;
            var timingFactor = Math.max(coiledStreet.length * 150, 1000);

            testDraw(vectorStreet, coiledStreet, 0, 0, scale);

            $({progressUnfold: 0}).delay(200).animate(
                {progressUnfold: 1}, 
                {duration: timingFactor*2, 
                 easing: "easeOutBounce",
                 progress: function(animation, progress) {
                    clearCanvas();
                    testDraw(vectorStreet, coiledStreet, this.progressUnfold, 0, scale);
                 },
                 complete: function (argument) {
                     $({progressStitch: 0}).delay(300).animate(
                        {progressStitch: 1}, 
                        {duration: timingFactor*1.2, 
                         easing: "easeInOutBack",
                         progress: function(animation, progress) {
                            clearCanvas();
                            testDraw(vectorStreet, coiledStreet, 1, this.progressStitch, scale);
                         },
                         complete: function(){
                            $({progressUnfold: 1, progressStitch: 1}).delay(800).animate(
                                {progressUnfold: 0, progressStitch: 0}, 
                                {duration: timingFactor*2, 
                                 easing: "easeInOutCubic",
                                 progress: function(animation, progress) {
                                    clearCanvas();
                                    testDraw(vectorStreet, coiledStreet, this.progressUnfold, this.progressStitch, scale);}
                                    , complete: function(){
                                        animate(vectorStreet, coiledStreet)
                                    }
                                })
                         }
                        }
                    );
                 }
                }
            );
        }

        function testDraw(originalStreet, coiledStreet, progressUnfold, progressRestitch, meterPerPixel){
            var scale = meterPerPixel / 1000;
            var boundingBox = {
              top: null,
              bottom: null,
              left: null,
              right: null
            }

            var originalGeometry = originalStreet.vectors;
            var coiledGeometry = coiledStreet.vectors;


            var cursor = {
                x:100 + coiledStreet.coilOrigin.x / scale, 
                y:100 + coiledStreet.coilOrigin.y / scale
            };
            var cursorCoordinates = {x:0, y:0};
            var angleCounter = 0;

            for (var j = 0; j < coiledGeometry.length; j++) {
                var angleDiff = getAngleDifference(originalGeometry[j].deltaBearing, coiledGeometry[j].deltaAngle);
                var distanceDiff = originalGeometry[j].distance - coiledGeometry[j].distance;

                var vector = coiledGeometry[j];

                var distance = (vector.distance + distanceDiff * progressUnfold) / scale;
                if (originalGeometry[j].type == "translation") {
                    distance = distance * progressRestitch;
                }

                

                
                angleCounter += vector.deltaAngle + angleDiff * progressUnfold;
                //angleCounter += vector.deltaAngle;

                var dx = Math.sin( toRadians(angleCounter) ) * distance;
                var dy = Math.cos( toRadians(angleCounter) ) * distance;

                if (originalGeometry[j].type == "translation") {
                    context.lineWidth = "1";
                    context.strokeStyle = "rgba(0,0,0, 0)";
                }else{
                    context.lineWidth = "2";
                    context.strokeStyle = "#50E3C2";
                }

                context.beginPath();
                context.moveTo(cursor.x, cursor.y);

                cursor.x += dx;
                cursor.y -= dy;

                var dxCoord = Math.sin( toRadians(angleCounter) ) * vector.distance;
                var dyCoord = Math.cos( toRadians(angleCounter) ) * vector.distance;

                cursorCoordinates.x += dxCoord;
                cursorCoordinates.y -= dyCoord;

                if (boundingBox.left == null || boundingBox.left > cursorCoordinates.x) {
                    boundingBox.left = cursorCoordinates.x
                }
                if (boundingBox.right == null || boundingBox.right < cursorCoordinates.x) {
                    boundingBox.right = cursorCoordinates.x
                }
                if (boundingBox.top == null || boundingBox.top > cursorCoordinates.y) {
                    boundingBox.top = cursorCoordinates.y
                }
                if (boundingBox.bottom == null || boundingBox.bottom < cursorCoordinates.y) {
                    boundingBox.bottom = cursorCoordinates.y
                }

                context.lineTo(cursor.x, cursor.y);
                context.stroke();
                context.closePath();
            };

            return boundingBox
        }

        // Returns coordinates of unfolded street
        //
        //   progress: How far animation has 
        //      From:  0 (start - no change)
        //      To:    1 (end - fully unfolded and rotated that start- and endpoint are on the same y)
        //
        //   unfoldAmplitude: How far 
        //     From:   0 (no unravel)
        //     To:     Infinity (values until 30 work nicely)
        function getUnfoldedStreetSimple(vectorStreet, progress, unfoldAmplitude){
            var unfoldFactor = 1 + progress * unfoldAmplitude;
            var output = unfold.getUnfoldedVectorStreet(vectorStreet, unfoldFactor, progress, progress);
            return output;
        }

        function clearCanvas(){
            //context.clearRect(0, 0, canvas.width, canvas.height);
            // context.fillStyle = "rgba(255,255,255,0.05)";
            // context.rect(0, 0, canvas.width, canvas.height);
            // context.fill();
        }

        function getMeterPerPixel(lat, zoomLevel){
            return (40075016.686 * Math.abs(Math.cos(toRadians(lat))) / Math.pow(2, zoomLevel + 9));
        }

        function getZoomLevel(lat, pixelPerMeter){
            return Math.log2(40075016.686 * ( Math.cos(toRadians(lat))/pixelPerMeter )) - 9;
        }

        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function getAngleDifference(angle1, angle2){
            var d = angle1 - angle2
             while (d < -180) {
                d += 360;
              };
              while (d > 180) {
                d -= 360;
              };
            return d;
          }
    </script>
  </head>
  <body>
    <h1>Coiling Example</h1>
    <h2>How Coiling Streets Could Work</h2> 
    <!-- <div id="svg">Calculating ... </br>(this will take a while)</div> -->
    <canvas id='canvas'width="1500" height="1500"></canvas>
    <div id="conclusion"></div>
    <!-- <div id="bottom">↓</div> -->
  </body>
 </html>