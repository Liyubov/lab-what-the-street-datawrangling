<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unravel</title>
  </head>
  <body>
    <canvas id="myCanvas" width="4000" height="4000"></canvas>
    <button id="unfold">Unfold</button>
    <style type="text/css">
    body{
      background: #eceaea;
    }
    canvas{
      background: white;
      margin: 30px;
    }

    #unfold{
      position: fixed;
      top: 30px;
      left: 30px;
    }
    </style>
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
        <script type="text/javascript" src="./js/async.min.js"></script>
        <script type="text/javascript" src="./js/jquery.easing.1.3.js"></script>
        <script>
            var canvas = document.getElementById("myCanvas"); //reference canvas
            var canvasContext = canvas.getContext("2d"); //set context

            init();

            function init(){
              var urlToJson = "./data/Achillesstraße.json"

              var pathToData = "./data/";
              //var filesToLoad = ['Achillesstraße.json', 'Columbiadamm.json', 'FrankfurterAllee.json', 'französischeStraße.json', 'Bäckerstraße.json', 'Wartburgstraße.json', 'Hohenstaufenstraße.json', 'Adlergestell.json'];
              var filesToLoad = ['Achillesstraße.json'];
              workFiles(pathToData, filesToLoad);
            }

            function getUnfoldedGeometry(vectors, unfold, restitching){
              var newVectors = JSON.parse(JSON.stringify(vectors));
              for (var i = 0; i < newVectors.length; i++) {
                var vector = newVectors[i];
                if (vector.type == "translation") {
                  vector.distance = vector.distance * restitching;
                };
                if (i!=0) { //for all except the first one
                  vector.deltaBearing = vector.deltaBearing / unfold;
                };
                
              };
              return newVectors;
            }

            function workFiles(pathToData, filesToLoad){
              console.log('');
              console.log('---------------------------');
              console.log('# Start loading files');
              async.map(filesToLoad, function(fileName, callback){
                var urlToJson = pathToData + fileName;
                console.log('Loading '+ urlToJson);
                $.getJSON( urlToJson, function(streetJson) {
                  console.log('Successfully loaded ' + urlToJson);
                  console.log(streetJson);
                  var street = getVectorLine(streetJson);
                  callback(null, street);
                });
              },function(err, streets){
                console.log('# All files loaded');
                console.log('---------------------------');
                console.log('streets', streets);
                $('#unfold').click(function(){
                  var duration = 2000;
                  var startOfUnfold = 0.55;

                  var easing = {
                    restitchTest: 1,
                    unfoldTest: 1
                  }
                  //restitch

                  $(easing).animate({restitchTest: 0}, {
                      duration: duration,
                      easing: "easeInOutQuart", 
                      queue: false,
                      step: function() { 
                        clearCanvas();
                        console.log('restitchTest', easing.restitchTest)
                        drawVectors(getUnfoldedGeometry(streets[0].vectors, easing.unfoldTest, easing.restitchTest), {x:200, y:800}, 300);
                      }
                  });

                  window.setTimeout(function(){
                    $(easing).animate({unfoldTest: 3}, {
                        duration: duration - duration * startOfUnfold,
                        queue: false,
                        easing: "easeInOutQuad", 
                        step: function() { 
                          console.log(easing.unfoldTest);
                        }
                    });
                  }, duration * startOfUnfold);
                });
              });
            }

            //obsolete
            // function animationTest(street){
            //   var counter = 0;
            //   window.setInterval(step, 100);
            //   function step(){
            //     var oscillator = Math.cos(counter/16)/2+0.5;
            //     var restitching = Math.abs(-oscillator);
            //     var unfold = 1 + (1 - oscillator)*10;
            //     console.log(oscillator);
            //     counter ++;
            //     clearCanvas();
            //     drawVectors(getUnfoldedGeometry(street.vectors, unfold, restitching), {x:200, y:800}, 300);
            //   }
            // }

            function getVectorLine(street){
              var components = street.components;
              var previousNode;
              var previousBearing = "start";

              var output = {};
                  output.tags = street.tags;
                  output.vectors = [];

              for (var c = 0; c < components.length; c++) {
                var component = components[c];
                var paths = component;
                for (var p = 0; p < paths.length; p++) {
                  var path = paths[p];
                  for (var n = 0; n < path.length; n++) {
                    
                    var node = path[n];

                    if (n==0 && p==0 && c==0) {
                      //Set Origin
                      console.log('Add origin');
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      output.origin = currentNodeLocation;
                    }else{
                      //Add Vector (gaps are also vectors)
                      console.log('Add vector');

                      var previousNodeLocation = getCoordinateFromNode(previousNode, street.nodes);
                      var previousNodePoint = turf.point([previousNodeLocation.lon, previousNodeLocation.lat]);

                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      var currentNodePoint = turf.point([currentNodeLocation.lon, currentNodeLocation.lat]);

                      var distance = turf.distance(previousNodePoint, currentNodePoint); //in km
                      var bearing = turf.bearing(previousNodePoint, currentNodePoint);

                      if (previousBearing == "start") {
                        var deltaBearing = bearing;
                      }else{
                        var deltaBearing = getAngleDifference( bearing, previousBearing );
                      }

                      if (n==0) { //First coordinate of path
                        console.log('vector is translation');
                        var type = "translation";
                      }else{
                        var type = "street";
                      }

                      var vector = {
                        deltaBearing: deltaBearing,
                        distance: distance,
                        type: type
                      }
                      output.vectors.push(vector);

                      previousBearing = bearing;
                    }
                    previousNode = node;
                  };
                };
              };
              return output;
            }

            function drawVectors(vectors, origin, scale){
              var bearingCounter = 0;
              var currentX = origin.x;
              var currentY = origin.y;
              var previousX = currentX;
              var previousY = currentY;


              var kmInPixel = scale; //= 1km
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;

                var pixelDistance = vector.distance * kmInPixel;
                //not correct because geo, but ok for our scale, use turf.destination() instead
                var dx = Math.sin(toRadians(bearingCounter)) * pixelDistance;
                var dy = Math.cos(toRadians(bearingCounter)) * pixelDistance;

                currentX += dx;
                currentY -= dy;

                if (vector.type == "street") {
                  canvasContext.strokeStyle = '#00B7BF';
                }else if(vector.type == "translation") {
                  //canvasContext.strokeStyle = 'rgba(0,0,0,0.06)';
                  canvasContext.strokeStyle = 'rgba(0,0,0,0)';
                }

                canvasContext.beginPath(); 
                canvasContext.moveTo(previousX, previousY);
                canvasContext.lineTo(currentX, currentY);
                canvasContext.stroke();
                canvasContext.closePath();

                previousX = currentX;
                previousY = currentY;
              };
            }

            function getAngleDifference(angle1, angle2){
              var d = angle1 - angle2
               while (d < -180) {
                  d += 360;
                };
                while (d > 180) {
                  d -= 360;
                };
              return d;
            }

            function toRadians(degrees) {
              return degrees * Math.PI / 180;
            };

            function getCoordinateFromNode(node, nodes){
              return nodes[node];
            }

            function clearCanvas(){
              canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            }

        </script>
  </body>
</html>