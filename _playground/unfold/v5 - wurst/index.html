<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unravel</title>
  </head>
  <body>
    <canvas id="myCanvas" width="4000" height="4000"></canvas>
    <button id="unfold">Unfold</button>
    <style type="text/css">
    body{
      background: #eceaea;
    }
    canvas{
      background: white;
      margin: 30px;
    }

    #unfold{
      position: fixed;
      top: 30px;
      left: 30px;
    }
    </style>
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
        <script type="text/javascript" src="./js/async.min.js"></script>
        <script type="text/javascript" src="./js/jquery.easing.1.3.js"></script>
        <script>
            var canvas = document.getElementById("myCanvas"); //reference canvas
            var canvasContext = canvas.getContext("2d"); //set context

            init();

            function init(){
              var urlToJson = "./data/Achillesstraße.json"

              var pathToData = "./data/";
              var filesToLoad = ['Achillesstraße.json', 'Columbiadamm.json', 'FrankfurterAllee.json', 'französischeStraße.json', 'Bäckerstraße.json', 'Wartburgstraße.json', 'Hohenstaufenstraße.json', 'Adlergestell.json'];
              //var filesToLoad = ['Columbiadamm.json', 'Achillesstraße.json'];
              workFiles(pathToData, filesToLoad);
            }

            function workFiles(pathToData, filesToLoad){
              console.log('');
              console.log('---------------------------');
              console.log('# Start loading files');
              async.map(filesToLoad, function(fileName, callback){
                var urlToJson = pathToData + fileName;
                console.log('Loading '+ urlToJson);
                $.getJSON( urlToJson, function(streetJson) {
                  console.log('Successfully loaded ' + urlToJson);
                  console.log(streetJson);
                  var street = getVectorLine(streetJson);
                  callback(null, street);
                });
              },function(err, streets){
                console.log('# All files loaded');
                console.log('---------------------------');
                console.log('streets', streets);

                var newStreets = [];
                for (var i = 0; i < streets.length; i++) {
                  newStreets.push(getUnfoldedStreet(streets[i],200 , 0, 0));
                };

                var allVectors = [];
                var previousDeltaBearing = 0;
                for (var i = 0; i < newStreets.length; i++) {
                  var street = newStreets[i];
                  var vectors = street.vectors;
                  var vectorsEdit = JSON.parse(JSON.stringify(street.vectors));
                  //vectorsEdit[0].deltaBearing = getAngleDifference(previousDeltaBearing, vectorsEdit[0].deltaBearing);
                  if (i == 0) {
                    vectorsEdit[0].deltaBearing = 90
                  }else{
                    vectorsEdit[0].deltaBearing = 0;
                  }
                  
                  for (var j = 0; j < vectorsEdit.length; j++) {
                    allVectors.push(vectorsEdit[j]);  
                  };
                  
                  console.log(vectorsEdit);

                  previousDeltaBearing = vectorsEdit[ vectorsEdit.length - 1 ];
                }

                console.log(allVectors)

                drawVectors(allVectors, {x:800, y:1200}, 300, 0);

                // var widthCounter = 200;
                // var gap = 15;
                // for (var i = 0; i < streets.length; i++) {
                //   var street = streets[i]
                //   var width = test(street, 1, widthCounter);
                //   widthCounter += width;
                //   widthCounter += gap;
                // };
              });
            }

            function test(street, progress, offset){
              //progress is from 
              var progressInverse = 1 - progress; //from 0 to 1;
              var unfold = 1 + progress * 3;
              var scale = 100;

              var unfoldedStreet = getUnfoldedStreet(street, unfold, progressInverse, progressInverse);
              var unfoldedStreetCoordinates = getCoordinatesFromVectors(unfoldedStreet.vectors, unfoldedStreet.origin);
              var lastCoordinate = unfoldedStreetCoordinates[ unfoldedStreetCoordinates.length - 1 ];
              var objectBearing = getBearing( street.origin, lastCoordinate );
              unfoldedStreet.objectBearing = objectBearing;
              unfoldedStreet.objectDistance
              var rotate = -getAngleDifference(unfoldedStreet.objectBearing, 90);
              console.log(unfoldedStreet.objectBearing, rotate);
              var width = drawVectors(unfoldedStreet.vectors, {x:offset, y:800}, scale, rotate * progress);
              return width;
            }


            function getUnfoldedStreet(street, unfold, closeGaps, straightenPathConnections){
              //closeGaps: Number between 0 (no gap) and 1 (original gap), larger numbers will result in larger gaps
              //unfold: Number between 1 (original) and inifinity (use values from 1 to around 5)
              //straightenPathConnections: Number between 0 (straight from last vector to now) and 1 (original angle)

              var previousVectorType;
              var newVectors = JSON.parse(JSON.stringify(street.vectors));

              for (var i = 0; i < newVectors.length; i++) {
                var vector = newVectors[i];
                if (vector.type == "translation") {
                  vector.deltaBearing = vector.deltaBearing*closeGaps;
                  vector.distance = vector.distance * closeGaps;
                };
                if (i!=0) { //for all except the first one
                  vector.deltaBearing = vector.deltaBearing / unfold;
                  if (previousVectorType == "translation") {
                    vector.deltaBearing = vector.deltaBearing * straightenPathConnections;
                  };
                };

                //last vector
                if (i == newVectors.length - 1) {

                };
                previousVectorType = vector.type;
              };


              var newStreet = {
                origin: JSON.parse(JSON.stringify(street.origin)),
                tags: JSON.parse(JSON.stringify(street.tags)),
                vectors: newVectors
              }
              
              return newStreet;
            }

            function getCoordinatesFromVectors(vectors, origin){
              var coordinates = [];
              var bearingCounter = 0;

              coordinates.push(origin);
              var cursor = JSON.parse(JSON.stringify(origin));
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;
                cursor = getDestination(cursor, vector.distance, bearingCounter);

                coordinates.push(cursor);
              };

              return coordinates;
            }

            function drawVectors(vectors, origin, scale, rotation){
              var bearingCounter = rotation;
              var currentX = origin.x;
              var currentY = origin.y;
              var previousX = currentX;
              var previousY = currentY;

              var distanceCounter = 0;
              var kmInPixel = scale; //= 1km
              var lastBendYTest = 0;
              var lastAction = "";
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;

                var pixelDistance = vector.distance * kmInPixel;
                distanceCounter += vector.distance;
                //not correct because geo, but ok for our scale, use turf.destination() instead
                var dx = Math.sin(toRadians(bearingCounter)) * pixelDistance;
                var dy = Math.cos(toRadians(bearingCounter)) * pixelDistance;

                currentX += dx;
                currentY -= dy;

                //test
                lastBendYTest -= dy;
                var slopeWidth = 400;
                var slopeHeight = 5;
                var x = currentX - origin.x;

                while(bearingCounter > 360){
                  bearingCounter -= 360;
                }

                while(bearingCounter < 0){
                  bearingCounter += 360;
                }

                if (x >= slopeWidth && lastAction != "firstRight"  && lastAction != "secondRight") {
                  console.log("bearingCounter", bearingCounter);
                  bearingCounter = 180;
                  lastBendYTest = 0;
                  lastAction = "firstRight";
                }else if (lastBendYTest > slopeHeight && lastAction == "firstRight") {
                    lastAction = "secondRight"                    
                    lastBendYTest = 0
                    bearingCounter = 270
                }else if (lastBendYTest > slopeHeight && lastAction == "firstLeft") {
                    lastAction = "secondLeft";
                    lastBendYTest = 0;
                    bearingCounter = 90;
                }else if (x <= 0 && lastAction != "firstLeft" && lastAction != "secondLeft") {
                  lastBendYTest = 0;
                  bearingCounter = 180;
                  lastAction = "firstLeft";
                }else{
                  console.log('none');
                }
                console.log(lastAction);

                if (lastAction == "firstRight") {
                  if (true) {};
                };

                
                //var x = distanceCounter*kmInPixel;
                //var modulo = x % (slopeWidth + slopeCurveLength)*2;
                // if (modulo < slopeWidth ) {
                //   //First segment = grey
                //   canvasContext.fillStyle = '#D8D8D8';
                // }else if (modulo < slopeWidth + slopeCurveLength ) {
                //   //Second segment = orange
                //   canvasContext.fillStyle = '#F6A623';
                //   bearingCounter += 8;
                // }else if (modulo < slopeWidth*2 ) {
                //   //third segment = again grey
                //   canvasContext.fillStyle = '#D8D8D8';
                // }else{
                //   //fourth segment = blue
                //   canvasContext.fillStyle = '#4990E2';
                //   bearingCounter -= 8;
                // }

                // canvasContext.beginPath(); 
                
                // canvasContext.arc(currentX, currentY, 3, 0, 2 * Math.PI, false);
                // canvasContext.fill();
                // canvasContext.closePath();

                //test

                if (vector.type == "street") {
                  canvasContext.strokeStyle = '#00B7BF';
                }else if(vector.type == "translation") {
                  canvasContext.strokeStyle = 'rgba(0,0,0,0.06)';
                  //canvasContext.strokeStyle = 'rgba(0,0,0,0)';
                }

                canvasContext.beginPath(); 
                canvasContext.moveTo(previousX, previousY);
                canvasContext.lineTo(currentX, currentY);
                canvasContext.stroke();
                canvasContext.closePath();

                previousX = currentX;
                previousY = currentY;
              };
              return currentX - origin.x;
            }

            function getVectorLine(street){
              var components = street.components;
              var previousNode;
              var previousBearing;

              var output = {};
                  output.tags = street.tags;
                  output.vectors = [];

              for (var c = 0; c < components.length; c++) {
                var component = components[c];
                var paths = component;

                for (var p = 0; p < paths.length; p++) {
                  var path = paths[p];

                  for (var n = 0; n < path.length; n++) {
                    var node = path[n];

                    //If first node of everything, then set origin and don't create vector (since a vector needs two nodes)
                    if (c==0 && p==0 && n==0) {
                      //Set Origin
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      output.origin = currentNodeLocation;
                    }else{
                      //Add Vector (gaps are also vectors)
                      var type;
                      var deltaBearing;
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      var previousNodeLocation = getCoordinateFromNode(previousNode, street.nodes);

                      var bearing = getBearing( previousNodeLocation, currentNodeLocation ); //in deg
                      var distance = getDistance( previousNodeLocation, currentNodeLocation ); //in km

                      //If it is the first vector, use the globale bearing, since it compares to the y-axis
                      if (c==0 && p==0 && n==1) { //if second node (first vector) of everything
                        deltaBearing = bearing;
                      }else{
                        deltaBearing = getAngleDifference( bearing, previousBearing );
                      }

                      //If first node of path (n==0), then the vector ending here is translation
                      if (n==0) { type = "translation";
                      }else{      type = "street";    }

                      //If last node of everything, then add destination and bearing of the object
                      if (p == paths.length -1 && n == path.length - 1 && c == components.length - 1) { 
                        console.log('last bit');
                        output.destination = currentNodeLocation;
                        output.objectBearing = getBearing( output.origin, output.destination );
                      };

                      //Prepare to output
                      var vector = {
                        deltaBearing: deltaBearing,
                        distance: distance,
                        type: type
                      }
                      output.vectors.push(vector);

                      //Update previous bearing (used to calculate the bearing difference)
                      previousBearing = bearing;
                    }

                    //Update previous node (used to calculate the vectors)
                    previousNode = node;
                  };
                };
              };
              return output;
            }







            //--------------------------
            //         Helpers
            //--------------------------

            function getAngleDifference(angle1, angle2){
              var d = angle1 - angle2
               while (d < -180) {
                  d += 360;
                };
                while (d > 180) {
                  d -= 360;
                };
              return d;
            }

            function getBearing(from, to){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.point([to.lon, to.lat]);
              return turf.bearing(fromPoint, toPoint);
            }

            function getDistance(from, to){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.point([to.lon, to.lat]);
              return turf.distance(fromPoint, toPoint);
            }

            function getDestination(from, distance, bearing){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.destination(fromPoint, distance, bearing);
              return {lon: toPoint.geometry.coordinates[0], lat: toPoint.geometry.coordinates[1]}
            }

            function toRadians(degrees) {
              return degrees * Math.PI / 180;
            };

            function getCoordinateFromNode(node, nodes){
              return nodes[node];
            }

            function clearCanvas(){
              canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            }

        </script>
  </body>
</html>