<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unravel</title>
  </head>
  <body>
    <canvas id="myCanvas" width="27000" height="600"></canvas>
    <button id="unfold">Unfold</button>
    <style type="text/css">
    body{
      background: #eceaea;
    }
    canvas{
      background: white;
      margin: 30px;
    }

    #unfold{
      position: fixed;
      top: 30px;
      left: 30px;
    }
    </style>
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/3.0.14/turf.js"></script>
        <script type="text/javascript" src="./js/async.min.js"></script>
        <script type="text/javascript" src="./js/jquery.easing.1.3.js"></script>
        <script>
            var canvas = document.getElementById("myCanvas"); //reference canvas
            var canvasContext = canvas.getContext("2d"); //set context

            init();

            function init(){
              var pathToData = "./data/";
              var fileToLoad = "allStreetsBerlin.json";
              var urlToJson = pathToData + fileToLoad;
              $.getJSON( urlToJson, function(streetJson) {
                  console.log('Successfully loaded ' + urlToJson);
                  console.log(streetJson);

                  var streets = [];
                  for (var i = 0; i < streetJson.length; i++) {
                    var street = getVectorLine(streetJson[i]);
                    streets.push(street);
                  };

                  var allStreetCoordinates = [];
                  for (var i = 0; i < streets.length; i++) {
                    var street = streets[i];
                    var streetCoordinates = test(street, 1);
                    allStreetCoordinates.push(streetCoordinates);
                  };
                  console.log(JSON.stringify(allStreetCoordinates));
                });


            }

            function test(street, progress){
              //progress is from 
              var unfold = 1 + progress * 10;
              var scale = 100;

              var unfoldedStreet = getUnfoldedStreet(street, unfold, progress, progress);
              var unfoldedStreetCoordinates = getCoordinatesFromVectors(unfoldedStreet.vectors, unfoldedStreet.origin);
              var lastCoordinate = unfoldedStreetCoordinates[ unfoldedStreetCoordinates.length - 1 ];
              var objectBearing = getBearing( street.origin, lastCoordinate );
              unfoldedStreet.objectBearing = objectBearing;
              unfoldedStreet.objectDistance
              var rotate = -getAngleDifference(unfoldedStreet.objectBearing, 90);
              return getStreetCoordinates(unfoldedStreet.vectors, scale, rotate * progress);
            }


            function getUnfoldedStreet(street, unfold, closeGaps, straightenPathConnections){
              //closeGaps: Number between 0 (original gap) and 1 (no gap), larger numbers will result in larger gaps
              //unfold: Number between 1 (original) and inifinity (use values from 1 to around 5)
              //straightenPathConnections: Number between 0 (original angle) and 1 (straight from last vector to now)

              closeGaps = 1 - closeGaps;
              straightenPathConnections = 1 - straightenPathConnections;
              var previousVectorType;
              var newVectors = JSON.parse(JSON.stringify(street.vectors));

              for (var i = 0; i < newVectors.length; i++) {
                var vector = newVectors[i];
                if (vector.type == "translation") {
                  vector.deltaBearing = vector.deltaBearing*closeGaps;
                  vector.distance = vector.distance * closeGaps;
                };
                if (i!=0) { //for all except the first one
                  vector.deltaBearing = vector.deltaBearing / unfold;
                  if (previousVectorType == "translation") {
                    vector.deltaBearing = vector.deltaBearing * straightenPathConnections;
                  };
                };

                //last vector
                if (i == newVectors.length - 1) {

                };
                previousVectorType = vector.type;
              };


              var newStreet = {
                origin: JSON.parse(JSON.stringify(street.origin)),
                tags: JSON.parse(JSON.stringify(street.tags)),
                vectors: newVectors
              }
              
              return newStreet;
            }

            function getCoordinatesFromVectors(vectors, origin){
              var coordinates = [];
              var bearingCounter = 0;

              coordinates.push(origin);
              var cursor = JSON.parse(JSON.stringify(origin));
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;
                cursor = getDestination(cursor, vector.distance, bearingCounter);

                coordinates.push(cursor);
              };

              return coordinates;
            }

            function getStreetCoordinates(vectors, scale, rotation){
              var output = [];
              var bearingCounter = rotation;
              var currentX = 0;
              var currentY = 0;
              var previousX = currentX;
              var previousY = currentY;

              var distanceCounter = 0;
              var kmInPixel = scale; //= 1km
              var lastBendYTest = 0;
              var lastAction = "";
              for (var i = 0; i < vectors.length; i++) {
                var vector = vectors[i];
                bearingCounter += vector.deltaBearing;
                distanceCounter += vector.distance;

                //not correct, better use turf.destination() instead
                var dx = Math.sin(toRadians(bearingCounter)) * vector.distance;
                var dy = Math.cos(toRadians(bearingCounter)) * vector.distance;

                currentX += dx;
                currentY -= dy;
             
                output.push({distance: distanceCounter, y: currentY});

                // while(bearingCounter > 360){
                //   bearingCounter -= 360;
                // }

                // while(bearingCounter < 0){
                //   bearingCounter += 360;
                // }

                previousX = currentX;
                previousY = currentY;
              };
              return output;
            }

            function getVectorLine(street){
              var components = street.components;
              var previousNode;
              var previousBearing;

              var output = {};
                  output.tags = street.tags;
                  output.vectors = [];

              for (var c = 0; c < components.length; c++) {
                var component = components[c];
                var paths = component;

                for (var p = 0; p < paths.length; p++) {
                  var path = paths[p];

                  for (var n = 0; n < path.length; n++) {
                    var node = path[n];

                    //If first node of everything, then set origin and don't create vector (since a vector needs two nodes)
                    if (c==0 && p==0 && n==0) {
                      //Set Origin
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      output.origin = currentNodeLocation;
                    }else{
                      //Add Vector (gaps are also vectors)
                      var type;
                      var deltaBearing;
                      var currentNodeLocation = getCoordinateFromNode(node, street.nodes);
                      var previousNodeLocation = getCoordinateFromNode(previousNode, street.nodes);

                      var bearing = getBearing( previousNodeLocation, currentNodeLocation ); //in deg
                      var distance = getDistance( previousNodeLocation, currentNodeLocation ); //in km

                      //If it is the first vector, use the globale bearing, since it compares to the y-axis
                      if (c==0 && p==0 && n==1) { //if second node (first vector) of everything
                        deltaBearing = bearing;
                      }else{
                        deltaBearing = getAngleDifference( bearing, previousBearing );
                      }

                      //If first node of path (n==0), then the vector ending here is translation
                      if (n==0) { type = "translation";
                      }else{      type = "street";    }

                      //If last node of everything, then add destination and bearing of the object
                      if (p == paths.length -1 && n == path.length - 1 && c == components.length - 1) { 
                        output.destination = currentNodeLocation;
                        output.objectBearing = getBearing( output.origin, output.destination );
                      };

                      //Prepare to output
                      var vector = {
                        deltaBearing: deltaBearing,
                        distance: distance,
                        type: type
                      }
                      output.vectors.push(vector);

                      //Update previous bearing (used to calculate the bearing difference)
                      previousBearing = bearing;
                    }

                    //Update previous node (used to calculate the vectors)
                    previousNode = node;
                  };
                };
              };
              return output;
            }







            //--------------------------
            //         Helpers
            //--------------------------

            function getAngleDifference(angle1, angle2){
              var d = angle1 - angle2
               while (d < -180) {
                  d += 360;
                };
                while (d > 180) {
                  d -= 360;
                };
              return d;
            }

            function getBearing(from, to){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.point([to.lon, to.lat]);
              return turf.bearing(fromPoint, toPoint);
            }

            function getDistance(from, to){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.point([to.lon, to.lat]);
              return turf.distance(fromPoint, toPoint);
            }

            function getDestination(from, distance, bearing){
              var fromPoint = turf.point([from.lon, from.lat]);
              var toPoint = turf.destination(fromPoint, distance, bearing);
              return {lon: toPoint.geometry.coordinates[0], lat: toPoint.geometry.coordinates[1]}
            }

            function toRadians(degrees) {
              return degrees * Math.PI / 180;
            };

            function getCoordinateFromNode(node, nodes){
              return nodes[node];
            }

            function clearCanvas(){
              canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            }

        </script>
  </body>
</html>