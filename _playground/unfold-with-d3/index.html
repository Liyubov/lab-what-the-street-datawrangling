<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <style>

    .centerline {
      fill: none;
      stroke-width: 0.5px;
      stroke-linejoin: round;
      stroke-linecap: round;
      stroke-dasharray: 4,6;
      stroke: #FFF;
    }

    .street1bg {
      fill: none;
      stroke: #777;
      stroke-width: 10px;
      stroke-linejoin: round;
    }
    .street1fg {
      fill: none;
      stroke: #CCC;
      stroke-width: 9px;
      stroke-linejoin: round;
    }
    .street2bg {
      fill: none;
      stroke: #777;
      stroke-width: 11.8px;
      stroke-linejoin: round;
    }
    .street2fg {
      fill: none;
      stroke: #CCC;
      stroke-width: 10.8px;
      stroke-linejoin: round;
    }
    .street3bg {
      fill: none;
      stroke: #777;
      stroke-width: 13.6px;
      stroke-linejoin: round;
    }
    .street3fg {
      fill: none;
      stroke: #CCC;
      stroke-width: 12.6px;
      stroke-linejoin: round;
    }
    .poi {
      fill: #F00;
      stroke: #F00;
      stroke-width: 4px;
      stroke-linejoin: round;
    }

  </style>
</head>
<body>
<div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
<script src="turf.min.js"></script>
<script src="grouppoints.js"></script>
<script>

var width = 1000,
    height = 3000,
    boundary = 150,
    speed = 2,
    zoomfactor = 2;
    numpointstogroup = 4;

var streetheight = 20;

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height);

var line = d3.svg.line().interpolate("basis");

// Top point
var rotation = 0; //-Math.PI / 12;
var turnflag = 1;
var ydelta = 0;
var ydeltabase = boundary;
var yprev = boundary;
var numstreetgeofeatures = 6;

d3.json("mdstitch.geojson",function(err,md){

  // http://bl.ocks.org/mbostock/4707858
  var projection = d3.geo.conicConformal();
  projection
    .scale(1)
    .translate([0,0]);
  var pth = d3.geo.path()
    .projection(projection);

  var b = pth.bounds(md),
      s = 1 * .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
      t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1]))];
  
  projection
      .scale(s)
      .translate(t);

  // Project to screen x/y
  var street1 = md.features[0].geometry.coordinates[0].map(projection),
      street2 = md.features[1].geometry.coordinates[0].map(projection),
      streetfull = street1.concat(street2)
      vertices = grouppoints(streetfull, numpointstogroup);

  // Find out first point
  t_new = [t[0]-vertices[0][0]+boundary, t[1]-vertices[0][1]+boundary];

  projection
    .scale(s)
    .translate(t_new);

  // Reproject
  street1 = md.features[0].geometry.coordinates[0].map(projection);
  street2 = md.features[1].geometry.coordinates[0].map(projection);
  streetfull = street1.concat(street2)
  // console.log(street1)  
  // console.log(street2)

  vertices = grouppoints(streetfull, numpointstogroup);
  groups = getGroups(streetfull, vertices);

  var streetparts = [street1, street2];

  var streetGroup = svg.append("g");

  var streetBg1 = streetGroup.append("path")
        .attr("class", "street1bg")
        .datum(street1)
        .attr("d", line);

  // var streetBg = streetGroup
  //     .data(streetparts)
  //     .enter()
  //     .append("path")
  //     .attr("class", function(d,i){
  //       console.log(streetparts);
  //       return "street"+(i+1)+"bg";
  //     })
  //     .attr("d", line);
  var streetFg1 = streetGroup.append("path")
      .attr("class", "street1fg")
      .datum(street1)
      .attr("d", line);
  var streetCenterline1 = streetGroup.append("path")
      .attr("class", "centerline")
      .datum(street1)
      .attr("d", line);
  var streetBg2 = streetGroup.append("path")
      .attr("class", "street3bg")
      .datum(street2)
      .attr("d", line);
  var streetFg2 = streetGroup.append("path")
      .attr("class", "street3fg")
      .datum(street2)
      .attr("d", line);
  var streetCenterLine2 = streetGroup.append("path")
      .attr("class", "centerline")
      .datum(street2)
      .attr("d", line);


  setTimeout(zoomin, 1000/speed);
  setTimeout(unroll, 4000/speed);


  function zoomin() {
    streetGroup.transition()
      .duration(3000/speed)
      .style("stroke-width", 2 + "px")
      .attr("transform", "translate(" + [-boundary*(zoomfactor-1),-boundary*(zoomfactor-1)] + ") scale(" + zoomfactor + ")");
  }

var j = 0;

  function unroll() {

    var next = groups.shift(),
        angle = shortest(getAngle(next.anchor, next.end) + rotation);

    // Reset original points for tweening
    streetfull.forEach(function(p, i){
      p.original = i < next.start[2] ? null : p.slice(0,2);
    });

    d3.selectAll("path").transition()
      .delay(50/speed)
      .duration(200/speed)
      .attrTween("d",function(){

        // Update path with partial rotation
        return function(t) {

          var rotate = rotator(t * angle, next.anchor);

          streetfull.forEach(rotate);

          return line(streetfull);

        };

      })
      .each("end",function(){

        // Check if we will overshoot. In that case, cut back.

        if (j%numstreetgeofeatures==numstreetgeofeatures-1) {

          // Snake line
          if (next.end[0] >= (width+boundary*(zoomfactor-1))/zoomfactor-boundary/zoomfactor && turnflag == 1) { // one turn downwards on right side
            rotation = rotation - Math.PI/2;
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            turnflag += 1;
          } else if  (next.end[0] >= (width+boundary*(zoomfactor-1))/zoomfactor-boundary/zoomfactor && turnflag == 2) { // turn to left
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            if (ydelta >= streetheight/zoomfactor) {
              turnflag += 1;
              ydeltabase = ydeltabase + ydelta;
              ydelta = 0;
              rotation = rotation - Math.PI/2;
            }
          } else if (next.end[0] <= boundary+boundary/zoomfactor/2 && turnflag == 3) { // one turn downwards on left side
            rotation = rotation + Math.PI/2;
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            turnflag += 1;
          }  else if (next.end[0] <= boundary+boundary/zoomfactor/2 && turnflag == 4) { // turn to right
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            if (ydelta >= streetheight/zoomfactor) {
              turnflag = 1;
              ydeltabase = ydeltabase + ydelta;
              ydelta = 0;
              rotation = rotation + Math.PI/2;
            }
          }

          // console.log(next.end[0], next.end[1])

          if (groups.length) {
            unroll();
          }
        }
        j = j+1;
      });

  }

});

// Turn into groups of anchor point, first point to rotate, last point to rotate
function getGroups(streetfull, vertices) {

  return vertices.slice(1).map(function(v, i){

    return {
      start: i ? streetfull[vertices[i][2] + 1] : streetfull[0],
      end: v,
      anchor: vertices[i]
    };

  });

}

// Return function to modify point in place based on rotation from its original x/y
// (Using .original for tweening)
function rotator(angle, anchor) {

  var cx = anchor[0],
      cy = anchor[1],
      cos = Math.cos(angle),
      sin = Math.sin(angle);

  return function(point, i) {

    var x,
        y,
        x2,
        y2;

    if (point.original) {
      x = point.original[0];
      y = point.original[1];
      x2 = (cos * (x - cx)) + (sin * (y - cy)) + cx;
      y2 = (cos * (y - cy)) - (sin * (x - cx)) + cy;

      point[0] = x2;
      point[1] = y2;
    }

  };

}

// Take the shorter angle
function shortest(angle) {

  while (angle < -Math.PI) {
    angle += 2 * Math.PI;
  }

  while (angle > Math.PI) {
    angle -= 2 * Math.PI;
  }

  return angle;

}

function getAngle(a, b) {

  return Math.atan2(b[1] - a[1], b[0] - a[0]);

}

</script>
</body>
</html>