<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <style>

    .centerline {
      fill: none;
      stroke-width: 0.5px;
      stroke-linejoin: round;
      stroke-linecap: round;
      stroke-dasharray: 4,6;
      stroke: #FFF;
    }
    .streetbg {
      fill: none;
      stroke: #777;
      stroke-width: 10px;
      stroke-linejoin: round;
    }
    .streetfg {
      fill: none;
      stroke: #CCC;
      stroke-width: 9px;
      stroke-linejoin: round;
    }

  </style>
</head>
<body>
<div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
<script src="turf.min.js"></script>
<script src="grouppoints.js"></script>
<script>

var width = 1000,
    height = 3000,
    boundary = 150,
    speed = 3,
    zoomfactor = 3;
    numpointstogroup = 5;

var streetheight = 20;

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height);

var line = d3.svg.line();

// Top point
var rotation = 0; //-Math.PI / 12;
var turnflag = 1;
var ydelta = 0;
var ydeltabase = boundary;
var yprev = boundary;
var numstreetgeofeatures = 3;

d3.json("mdhannoversche.geojson",function(err,md){

  // http://bl.ocks.org/mbostock/4707858
  var projection = d3.geo.conicConformal();
  projection
    .scale(1)
    .translate([0,0]);
  var pth = d3.geo.path()
    .projection(projection);

  var b = pth.bounds(md),
      s = 1 * .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
      t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1]))];
  console.log(b);
  projection
      .scale(s)
      .translate(t);

  // Project to screen x/y
  var streetline = md.features[0].geometry.coordinates[0].map(projection),
      vertices = grouppoints(streetline, numpointstogroup);

  // Find out first point
  t_new = [t[0]-vertices[0][0]+boundary, t[1]-vertices[0][1]+boundary];

  projection
    .scale(s)
    .translate(t_new);

  // Reproject
  streetline = md.features[0].geometry.coordinates[0].map(projection);

  vertices = grouppoints(streetline, numpointstogroup);
  groups = getGroups(streetline, vertices);

  var streetGroup = svg.append("g");

  var streetBg = streetGroup.append("path")
      .attr("class", "streetbg")
      .datum(streetline)
      .attr("d", line);
  var streetFg = streetGroup.append("path")
      .attr("class", "streetfg")
      .datum(streetline)
      .attr("d", line);
  var streetCenterline = streetGroup.append("path")
      .attr("class", "centerline")
      .datum(streetline)
      .attr("d", line);

  setTimeout(zoomin, 1000/speed);
  setTimeout(unroll, 4000/speed);


  function zoomin() {
    streetGroup.transition()
      .duration(3000/speed)
      .style("stroke-width", 2 + "px")
      .attr("transform", "translate(" + [-boundary*(zoomfactor-1),-boundary*(zoomfactor-1)] + ") scale(" + zoomfactor + ")");
  }

var j = 0;

  function unroll() {

    var next = groups.shift(),
        angle = shortest(getAngle(next.anchor, next.end) + rotation);

    console.log(next.end[0])

    // Reset original points for tweening
    streetline.forEach(function(p, i){
      p.original = i < next.start[2] ? null : p.slice(0,2);
    });


    d3.selectAll("path").transition()
      .delay(50/speed)
      .duration(200/speed)
      .attrTween("d",function(){

        // Update path with partial rotation
        return function(t) {

          var rotate = rotator(t * angle, next.anchor);

          streetline.forEach(rotate);

          return line(streetline);

        };

      })
      .each("end",function(){

        // Check if we will overshoot. In that case, cut back.

        if (j%numstreetgeofeatures==numstreetgeofeatures-1) {

          // Snake line
          if (next.end[0] >= (width+boundary*(zoomfactor-1))/zoomfactor-boundary/zoomfactor && turnflag == 1) { // one turn downwards on right side
            rotation = rotation - Math.PI/2;
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            turnflag += 1;
          } else if  (next.end[0] >= (width+boundary*(zoomfactor-1))/zoomfactor-boundary/zoomfactor && turnflag == 2) { // turn to left
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            if (ydelta >= streetheight/zoomfactor) {
              turnflag += 1;
              ydeltabase = ydeltabase + ydelta;
              ydelta = 0;
              rotation = rotation - Math.PI/2;
            }
          } else if (next.end[0] <= boundary+boundary/zoomfactor/2 && turnflag == 3) { // one turn downwards on left side
            rotation = rotation + Math.PI/2;
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            turnflag += 1;
          }  else if (next.end[0] <= boundary+boundary/zoomfactor/2 && turnflag == 4) { // turn to right
            ydelta += next.end[1] - yprev;
            yprev = next.end[1];
            if (ydelta >= streetheight/zoomfactor) {
              turnflag = 1;
              ydeltabase = ydeltabase + ydelta;
              ydelta = 0;
              rotation = rotation + Math.PI/2;
            }
          }

          // console.log(next.end[0], next.end[1])

          if (groups.length) {
            unroll();
          }
        }
        j = j+1;
      });

  }

});

// Turn into groups of anchor point, first point to rotate, last point to rotate
function getGroups(streetline, vertices) {

  return vertices.slice(1).map(function(v, i){

    return {
      start: i ? streetline[vertices[i][2] + 1] : streetline[0],
      end: v,
      anchor: vertices[i]
    };

  });

}

// Return function to modify point in place based on rotation from its original x/y
// (Using .original for tweening)
function rotator(angle, anchor) {

  var cx = anchor[0],
      cy = anchor[1],
      cos = Math.cos(angle),
      sin = Math.sin(angle);

  return function(point, i) {

    var x,
        y,
        x2,
        y2;

    if (point.original) {
      x = point.original[0];
      y = point.original[1];
      x2 = (cos * (x - cx)) + (sin * (y - cy)) + cx;
      y2 = (cos * (y - cy)) - (sin * (x - cx)) + cy;

      point[0] = x2;
      point[1] = y2;
    }

  };

}

// Take the shorter angle
function shortest(angle) {

  while (angle < -Math.PI) {
    angle += 2 * Math.PI;
  }

  while (angle > Math.PI) {
    angle -= 2 * Math.PI;
  }

  return angle;

}

function getAngle(a, b) {

  return Math.atan2(b[1] - a[1], b[0] - a[0]);

}

</script>
</body>
</html>