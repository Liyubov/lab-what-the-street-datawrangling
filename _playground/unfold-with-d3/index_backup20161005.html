<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <style>

    path {
      fill: none;
      stroke-width: 1px;
      stroke-linejoin: round;
      stroke-dasharray: 6,8;
      border-style: ;
    }

    .state {
      stroke: #777;
    }

  </style>
</head>
<body>
<div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
<script src="simplify.js"></script>
<script>

var width = 1260,
    height = 2000;

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height);

var projection = d3.geo.conicConformal()
  //.parallels([ 52.5186369, 52.5194611])
  //.rotate([177, -37 - 40 / 60])
  //.scale(20000085)
  //.parallels([38 + 18 / 60, 39 + 27 / 60])
  .rotate([0, 0])
  .scale(10000000)
  .center([13.3815232, 52.5280576])
  .translate([500, 0]);
  //.translate([520, 500]);

var line = d3.svg.line();

// Top point
var rotation = 0; //-Math.PI / 12;
var turnflag = 1;
var ydelta = 0;
var ydeltabase = 100;
var yprev = 0;

d3.json("mdhannoversche.geojson",function(err,md){

  // Project to screen x/y
  var border = md.features[0].geometry.coordinates[0].map(projection),
      vertices = simplify(border, 100),
      groups = getGroups(border, vertices);

  var state = svg.append("path")
    .attr("class", "state")
    .datum(border)
    .attr("d", line);


  setTimeout(unroll, 500);

  function unroll() {

    var next = groups.shift(),
        angle = shortest(getAngle(next.anchor, next.end) + rotation);


    // Reset original points for tweening
    border.forEach(function(p, i){
      p.original = i < next.start[2] ? null : p.slice(0,2);
    });

    state.transition()
      .delay(50)
      .duration(200)
      .attrTween("d",function(){

        // Update path with partial rotation
        return function(t) {

          var rotate = rotator(t * angle, next.anchor);

          border.forEach(rotate);

          return line(border);

        };

      })
      .each("end",function(){

        // Zig zag
        if (next.end[0] >= 760 && turnflag == 1) { // one turn downwards on right side
          rotation = rotation - Math.PI/2;
          ydelta += next.end[1] - yprev;
          yprev = next.end[1];
          turnflag += 1;
        } else if  (next.end[0] >= 760 && turnflag == 2) { // turn to left
          ydelta += next.end[1] - yprev;
          yprev = next.end[1];
          if (ydelta >= 100) {
            turnflag += 1;
            ydeltabase = ydeltabase + ydelta;
            ydelta = 0;
            rotation = rotation - Math.PI/2;
          }
        } else if (next.end[0] <= 150 && turnflag == 3) { // one turn downwards on left side
          rotation = rotation + Math.PI/2;
          ydelta += next.end[1] - yprev;
          yprev = next.end[1];
          turnflag += 1;
        }  else if (next.end[0] <= 150  && turnflag == 4) { // turn to right
          ydelta += next.end[1] - yprev;
          yprev = next.end[1];
          if (ydelta >= 100) {
            turnflag = 1;
            ydeltabase = ydeltabase + ydelta;
            ydelta = 0;
            rotation = rotation + Math.PI/2;
          }
        }

        console.log(next.end[0], next.end[1])
        if (groups.length) {
          unroll();
        }

      });

  }

});

// Turn into groups of anchor point, first point to rotate, last point to rotate
function getGroups(border, vertices) {

  return vertices.slice(1).map(function(v, i){

    return {
      start: i ? border[vertices[i][2] + 1] : border[0],
      end: v,
      anchor: vertices[i]
    };

  });

}

// Return function ro modify point in place based on rotation from its original x/y
// (Using .original for tweening)
function rotator(angle, anchor) {

  var cx = anchor[0],
      cy = anchor[1],
      cos = Math.cos(angle),
      sin = Math.sin(angle);

  return function(point, i) {

    var x,
        y,
        x2,
        y2;

    if (point.original) {
      x = point.original[0];
      y = point.original[1];
      x2 = (cos * (x - cx)) + (sin * (y - cy)) + cx;
      y2 = (cos * (y - cy)) - (sin * (x - cx)) + cy;

      point[0] = x2;
      point[1] = y2;
    }

  };

}

// Take the shorter angle
function shortest(angle) {

  while (angle < -Math.PI) {
    angle += 2 * Math.PI;
  }

  while (angle > Math.PI) {
    angle -= 2 * Math.PI;
  }

  return angle;

}

function getAngle(a, b) {

  return Math.atan2(b[1] - a[1], b[0] - a[0]);

}

</script>
</body>
</html>